<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Muse Mirror</title>
  <style>
    @import url('https://fonts.cdnjs.com/css2?family=Inter:wght@300;400&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      background-color: white;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      position: relative;
    }

    #fixed-center {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 800px;
    }

    #input-line {
      display: flex;
      align-items: center;
      height: 30px;
    }

    #displayed-text {
      font-weight: 300;
      font-size: 20px;
      letter-spacing: -0.01em;
      color: #333;
      white-space: pre;
    }

    #cursor {
      display: inline-block;
      width: 2px;
      height: 24px;
      background-color: #333;
      animation: breathe 4.5s infinite ease-in-out;
      margin-left: 1px;
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.2; }
      50% { opacity: 1; }
    }

    #hidden-input {
      position: absolute;
      opacity: 0;
      height: 0;
      width: 0;
    }

    #conversation {
      position: absolute;
      width: 100%;
      max-height: 45vh;
      overflow-y: auto;
      display: flex;
      flex-direction: column-reverse;
      bottom: 100%;
      margin-bottom: 10px;
    }

    .conversation-item {
      margin-bottom: 10px;
      font-size: 20px;
      letter-spacing: -0.01em;
      font-weight: 300;
      line-height: 1.5;
      text-align: left;
      transition: transform 0.4s ease-out;
    }

    .user-text {
      color: #333;
    }

    .response-text {
      color: #666;
      opacity: 0;
      animation: fadeIn 2s forwards;
    }

    .smooth-transition {
      transition: opacity 0.5s ease-out;
    }

    @keyframes fadeIn {
      to { opacity: 1; }
    }

    #canvas-container {
      position: fixed;
      left: 0;
      right: 0;
      top: calc(50% + 15px);
      bottom: 0;
      display: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #drawing-canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
      background-color: white;
    }

    #canvas-gradient {
      position: absolute;
      top: -2px;
      left: 0;
      width: 100%;
      height: calc(100% + 2px);
      pointer-events: none;
      background: linear-gradient(to bottom,
        rgba(255, 255, 255, 1) 0%,
        rgba(255, 255, 255, 0.96) 4%,
        rgba(255, 255, 255, 0.8) 10%,
        rgba(255, 255, 255, 0.4) 18%,
        rgba(255, 255, 255, 0) 30%);
    }

    .canvas-visible {
      opacity: 1 !important;
    }
  </style>
</head>
<body>
  <div id="fixed-center">
    <div id="conversation"></div>
    <div id="input-line">
      <span id="displayed-text"></span>
      <span id="cursor"></span>
      <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
    </div>
  </div>
  <div id="settings-icon" style="display:none; position:fixed; top:24px; right:24px; z-index:10; cursor:pointer;">
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="3.5"/>
      <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 1 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 1 1-4 0v-.09a1.65 1.65 0 0 0-1-1.51 1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 1 1-2.83-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 1 1 0-4h.09a1.65 1.65 0 0 0 1.51-1 1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 1 1 2.83-2.83l.06.06a1.65 1.65 0 0 0 1.82.33h.09A1.65 1.65 0 0 0 9 3.09V3a2 2 0 1 1 4 0v.09c0 .66.39 1.26 1 1.51a1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 1 1 2.83 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82v.09c.22.61.85 1 1.51 1H21a2 2 0 1 1 0 4h-.09c-.66 0-1.26.39-1.51 1z"/>
    </svg>
  </div>
  <div id="auth-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(255,255,255,0.96); z-index:100; align-items:center; justify-content:center;">
    <div style="background:white; border-radius:10px; box-shadow:0 2px 16px rgba(0,0,0,0.07); padding:32px 24px; min-width:260px; max-width:90vw; display:flex; flex-direction:column; align-items:center;">
      <div id="auth-modal-content">
        <h2 style="font-size:1.1em; font-weight:400; margin-bottom:18px; color:#222;">Sign in to continue</h2>
        <input id="auth-email" type="email" placeholder="your@email.com" style="font-size:1em; padding:8px 12px; border:1px solid #ddd; border-radius:5px; outline:none; margin-bottom:12px; width:100%;" />
        <button id="auth-send-link" style="font-size:1em; padding:8px 0; border:none; background:#222; color:white; border-radius:5px; width:100%; cursor:pointer;">Send magic link</button>
        <div id="auth-message" style="margin-top:12px; font-size:0.95em; color:#444; min-height:1.2em;"></div>
      </div>
      <button id="auth-close" style="margin-top:18px; background:none; border:none; color:#888; font-size:0.95em; cursor:pointer;">Cancel</button>
    </div>
  </div>
  <div id="account-modal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(255,255,255,0.96); z-index:100; align-items:center; justify-content:center;">
    <div style="background:white; border-radius:10px; box-shadow:0 2px 16px rgba(0,0,0,0.07); padding:32px 24px; min-width:260px; max-width:90vw; display:flex; flex-direction:column; align-items:center;">
      <div id="account-modal-content">
        <h2 style="font-size:1.1em; font-weight:400; margin-bottom:18px; color:#222;">Account</h2>
        <div id="account-email" style="font-size:1em; color:#333; margin-bottom:8px;"></div>
        <div id="account-tier" style="font-size:0.98em; color:#666; margin-bottom:16px;"></div>
        <button id="account-upgrade" style="display:none; font-size:1em; padding:8px 0; border:none; background:#222; color:white; border-radius:5px; width:100%; cursor:pointer; margin-bottom:10px;">Upgrade to Premium</button>
        <button id="account-logout" style="font-size:0.95em; padding:6px 0; border:none; background:#eee; color:#444; border-radius:5px; width:100%; cursor:pointer;">Log out</button>
      </div>
      <button id="account-close" style="margin-top:18px; background:none; border:none; color:#888; font-size:0.95em; cursor:pointer;">Close</button>
    </div>
  </div>
  <div id="canvas-container">
    <canvas id="drawing-canvas"></canvas>
    <div id="canvas-gradient"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    const supabaseUrl = 'https://grtbltrjiluriwfjcfva.supabase.co';
    const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdydGJsdHJqaWx1cml3ZmpjZnZhIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5NzUzNTAsImV4cCI6MjA2NDU1MTM1MH0.wfPdmrheZ45DPAJqYoO0v8yFnMrt4eX5w6g4EzhBPB4';
    const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);

    // --- User State ---
    let user = null;
    let profile = null;
    let dailyExchanges = 0;
    let tier = 'anonymous';
    let lastExchangeDate = null;
    let localExchanges = 0;
    let localLastDate = null;
    const EXCHANGES = { anonymous: 1, free: 3, premium: 40 };
    const MESSAGES_PER_EXCHANGE = 8;
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let canvasActivated = false;
    let messageCount = 0;
    let exchangeCount = 0;
    let currentExchangeMessages = 0;

    // --- DOM references ---
    let settingsIcon, authModal, authEmail, authSendLink, authMessage, authClose;
    let hiddenInput, displayedText, conversation, cursor, canvasContainer, canvas, ctx;
    let accountModal, accountEmail, accountTier, accountUpgrade, accountLogout, accountClose;

    const fallbackResponses = [
      "My reflections are caught somewhere between worlds. Try again soon."
    ];

    // --- Local Storage for Anonymous ---
    function getToday() {
      const now = new Date();
      return now.toISOString().slice(0,10);
    }
    function loadLocalExchanges() {
      localExchanges = parseInt(localStorage.getItem('mm_localExchanges')||'0',10);
      localLastDate = localStorage.getItem('mm_localLastDate')||getToday();
      if (localLastDate !== getToday()) {
        localExchanges = 0;
        localLastDate = getToday();
        localStorage.setItem('mm_localExchanges', '0');
        localStorage.setItem('mm_localLastDate', localLastDate);
      }
    }
    function incLocalExchanges() {
      localExchanges++;
      localStorage.setItem('mm_localExchanges', localExchanges);
      localStorage.setItem('mm_localLastDate', getToday());
    }

    // --- Auth Modal Logic ---
    function showAuthModal() {
      authModal.style.display = 'flex';
      authEmail.value = '';
      authMessage.textContent = '';
      authEmail.focus();
    }
    function hideAuthModal() {
      authModal.style.display = 'none';
    }

    // --- Exchange Tracking ---
    function resetSessionCounters() {
      exchangeCount = 0;
      currentExchangeMessages = 0;
      messageCount = 0;
    }
    
    async function onExchangeEnd() {
      currentExchangeMessages = 0;
      exchangeCount++;
      console.log('[MuseMirror] Exchange ended. exchangeCount =', exchangeCount, 'tier =', tier);
      if (tier === 'anonymous') {
        incLocalExchanges();
        console.log('[MuseMirror] Anonymous: localExchanges =', localExchanges);
      } else {
        await incProfileExchanges();
        await fetchProfile();
        console.log('[MuseMirror] Authenticated: dailyExchanges =', dailyExchanges, 'tier =', tier);
      }
      if ((tier === 'anonymous' && localExchanges >= EXCHANGES.anonymous) ||
          (tier === 'free' && dailyExchanges >= EXCHANGES.free)) {
        settingsIcon.style.display = 'block';
      }
      setTimeout(() => {
        console.log('[MuseMirror] After exchange: canSendMessage =', canSendMessage(), 'currentExchangeMessages =', currentExchangeMessages, 'dailyExchanges =', dailyExchanges, 'tier =', tier);
        if (canSendMessage()) {
          focusInput();
        } else {
          hiddenInput.disabled = true;
        }
      }, 500);
    }

    function canSendMessage() {
      if (tier === 'anonymous') {
        return localExchanges < EXCHANGES.anonymous && currentExchangeMessages < MESSAGES_PER_EXCHANGE;
      } else if (tier === 'free') {
        return dailyExchanges < EXCHANGES.free && currentExchangeMessages < MESSAGES_PER_EXCHANGE;
      } else if (tier === 'premium') {
        return dailyExchanges < EXCHANGES.premium && currentExchangeMessages < MESSAGES_PER_EXCHANGE;
      }
      return false;
    }

    // --- DOMContentLoaded/Onload Handler ---
    window.onload = async function () {
      // Enhanced Supabase Auth event handler for debugging and session refresh
      function handleSessionEvent(session, eventLabel) {
        console.log(`[MuseMirror] handleSessionEvent called from ${eventLabel}. Session:`, session);
        if (session && session.user) {
          user = session.user;
          fetchProfile().then(() => {
            console.log(`[MuseMirror] ${eventLabel}: Authenticated user. tier =`, tier, 'dailyExchanges =', dailyExchanges);
            updateTierUI();
            if (canSendMessage()) {
              focusInput();
            } else {
              hiddenInput.disabled = true;
            }
          });
        } else {
          user = null;
          profile = null;
          tier = 'anonymous';
          loadLocalExchanges();
          resetSessionCounters();
          console.log(`[MuseMirror] ${eventLabel}: Anonymous user. localExchanges =`, localExchanges);
          updateTierUI();
          if (canSendMessage()) {
            focusInput();
          } else {
            hiddenInput.disabled = true;
          }
        }
      }

      supabase.auth.onAuthStateChange(async (event, session) => {
        console.log('[MuseMirror] Auth state changed:', event, session);
        if (event === 'TOKEN_REFRESHED') {
          console.log('[MuseMirror] Session token refreshed.');
        }
        if (event === 'SIGNED_OUT') {
          console.warn('[MuseMirror] User was signed out unexpectedly.');
        }
        if (event === 'INITIAL_SESSION' || event === 'SIGNED_IN') {
          handleSessionEvent(session, event);
        }
        if (event === 'PASSWORD_RECOVERY') {
          console.log('[MuseMirror] Password recovery event.');
        }
        if (event === 'USER_UPDATED') {
          console.log('[MuseMirror] User updated.');
        }
      });

      // DOM references
      settingsIcon = document.getElementById('settings-icon');
      authModal = document.getElementById('auth-modal');
      authEmail = document.getElementById('auth-email');
      authSendLink = document.getElementById('auth-send-link');
      authMessage = document.getElementById('auth-message');
      authClose = document.getElementById('auth-close');
      hiddenInput = document.getElementById('hidden-input');
      displayedText = document.getElementById('displayed-text');
      conversation = document.getElementById('conversation');
      cursor = document.getElementById('cursor');
      canvasContainer = document.getElementById('canvas-container');
      canvas = document.getElementById('drawing-canvas');
      ctx = canvas.getContext('2d');
      accountModal = document.getElementById('account-modal');
      accountEmail = document.getElementById('account-email');
      accountTier = document.getElementById('account-tier');
      accountUpgrade = document.getElementById('account-upgrade');
      accountLogout = document.getElementById('account-logout');
      accountClose = document.getElementById('account-close');

      // Auth modal events
      authClose.onclick = hideAuthModal;
      authModal.onclick = (e) => { if (e.target === authModal) hideAuthModal(); };
      authSendLink.onclick = async () => {
        const email = authEmail.value.trim();
        if (!email) { authMessage.textContent = 'Enter your email.'; return; }
        authSendLink.disabled = true;
        authMessage.textContent = 'Sending magic link...';
        const { error } = await supabase.auth.signInWithOtp({ email });
        if (error) {
          authMessage.textContent = 'Error: ' + error.message;
        } else {
          authMessage.textContent = 'Check your email for the link.';
        }
        authSendLink.disabled = false;
      };

      // Account modal events
      accountClose.onclick = () => { accountModal.style.display = 'none'; };
      accountModal.onclick = (e) => { if (e.target === accountModal) accountModal.style.display = 'none'; };
      accountLogout.onclick = async () => {
        await supabase.auth.signOut();
        accountModal.style.display = 'none';
        // Reset to anonymous state
        user = null;
        profile = null;
        tier = 'anonymous';
        updateTierUI();
      };
      accountUpgrade.onclick = () => {
        // Placeholder: Integrate Stripe here
        alert('Upgrade to premium coming soon.');
      };

      // Settings icon click
      settingsIcon.onclick = () => {
        if (tier === 'anonymous') {
          showAuthModal();
        } else {
          // Show account modal for authenticated users
          if (user) {
            accountEmail.textContent = user.email || '';
            accountTier.textContent = tier.charAt(0).toUpperCase() + tier.slice(1) + ' account';
            if (tier === 'free') {
              accountUpgrade.style.display = 'block';
            } else {
              accountUpgrade.style.display = 'none';
            }
            accountModal.style.display = 'flex';
          }
        }
      };

      // Input focus
      focusInput();
      window.addEventListener('resize', () => {
        if (canvasActivated) {
          setupCanvas();
        }
      });

      document.addEventListener('click', (e) => {
        if (e.target !== canvas) focusInput();
      });
      document.getElementById('input-line').addEventListener('click', focusInput);
      hiddenInput.addEventListener('input', () => {
        displayedText.textContent = hiddenInput.value;
      });

      hiddenInput.addEventListener('keydown', async (e) => {
        if (e.key === 'Enter' && hiddenInput.value.trim() !== '') {
          e.preventDefault();
          if (!canSendMessage()) return;

          const userText = hiddenInput.value.trim();
          displayedText.classList.add('smooth-transition');
          const userItem = document.createElement('div');
          userItem.classList.add('conversation-item', 'user-text');
          userItem.textContent = userText;
          displayedText.style.opacity = '0';

          setTimeout(async () => {
            hiddenInput.value = '';
            displayedText.textContent = '';
            displayedText.style.opacity = '1';
            conversation.prepend(userItem);
            messageCount++;
            currentExchangeMessages++;
            console.log('[MuseMirror] User message sent. messageCount =', messageCount, 'currentExchangeMessages =', currentExchangeMessages);

            // Enforce 4 user messages per exchange (not 8 total)
            if (currentExchangeMessages >= 4) {
              console.log('[MuseMirror] 4-user-message limit reached. Ending exchange.');
              const currentOpacity = window.getComputedStyle(cursor).opacity;
              cursor.style.opacity = currentOpacity;
              cursor.style.animation = 'none';
              requestAnimationFrame(() => {
                cursor.style.transition = 'opacity 5s ease-out';
                cursor.style.opacity = '0';
              });
              hiddenInput.disabled = true;
              hiddenInput.blur();
              await onExchangeEnd();
              return;
            }

            if (!canvasActivated) {
              canvasContainer.style.display = 'block';
              canvasActivated = true;
              setupCanvas();
              canvas.addEventListener('mousedown', startDrawing);
              canvas.addEventListener('mousemove', draw);
              canvas.addEventListener('mouseup', stopDrawing);
              canvas.addEventListener('mouseout', stopDrawing);
              canvas.addEventListener('touchstart', function (e) {
                e.preventDefault();
                const touch = e.touches[0];
                canvas.dispatchEvent(new MouseEvent('mousedown', {
                  clientX: touch.clientX, clientY: touch.clientY
                }));
              });
              canvas.addEventListener('touchmove', function (e) {
                e.preventDefault();
                const touch = e.touches[0];
                canvas.dispatchEvent(new MouseEvent('mousemove', {
                  clientX: touch.clientX, clientY: touch.clientY
                }));
              });
              canvas.addEventListener('touchend', () => {
                canvas.dispatchEvent(new MouseEvent('mouseup'));
              });
            }

            setTimeout(async () => {
              let responseText;
              try {
                const response = await fetch('/api/mirror', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ message: userText })
                });
                const data = await response.json();
                responseText = data.reply;
              } catch (error) {
                responseText = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
              }

              const responseItem = document.createElement('div');
              responseItem.classList.add('conversation-item', 'response-text');
              responseItem.textContent = responseText;
              conversation.prepend(responseItem);
              console.log('[MuseMirror] Assistant response added. messageCount =', messageCount, 'currentExchangeMessages =', currentExchangeMessages);

              // Do NOT increment currentExchangeMessages here!

              if (!canSendMessage()) {
                settingsIcon.style.display = 'block';
              }
            }, 500);
          }, 500);
        }
      });
    };

    // --- Fetch Profile ---
    async function fetchProfile() {
      const { data, error } = await supabase.from('profiles').select('*').eq('id', user.id).single();
      if (data) {
        profile = data;
        tier = data.tier;
        dailyExchanges = data.daily_exchanges || 0;
        lastExchangeDate = data.last_exchange_date;
        // Daily reset
        if (lastExchangeDate !== getToday()) {
          await supabase.from('profiles').update({ daily_exchanges: 0, last_exchange_date: getToday() }).eq('id', user.id);
          dailyExchanges = 0;
        }
      } else {
        tier = 'free';
        dailyExchanges = 0;
      }
    }

    // --- Update Profile Exchange Count ---
    async function incProfileExchanges() {
      dailyExchanges++;
      await supabase.from('profiles').update({ daily_exchanges: dailyExchanges, last_exchange_date: getToday() }).eq('id', user.id);
    }

    // --- UI Tier State ---
    function updateTierUI() {
      // Show/hide settings icon for authenticated users at/over their limit
      if (tier === 'free' && dailyExchanges >= EXCHANGES.free) {
        settingsIcon.style.display = 'block';
      } else if (tier === 'premium' && dailyExchanges >= EXCHANGES.premium) {
        settingsIcon.style.display = 'block';
      } else if (tier !== 'anonymous') {
        settingsIcon.style.display = 'block';
      } else {
        settingsIcon.style.display = 'none';
      }
    }

    function focusInput() {
      if (canSendMessage()) {
        hiddenInput.disabled = false;
        hiddenInput.focus();
      } else {
        hiddenInput.disabled = true;
      }
    }

    function setupCanvas() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvas.offsetWidth * dpr;
      canvas.height = canvas.offsetHeight * dpr;
      ctx.scale(dpr, dpr);
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.strokeStyle = '#000';
    }

    function startDrawing(e) {
      isDrawing = true;
      const rect = canvas.getBoundingClientRect();
      lastX = e.clientX - rect.left;
      lastY = e.clientY - rect.top;
      canvasContainer.classList.add('canvas-visible');
    }

    function draw(e) {
      if (!isDrawing) return;
      const rect = canvas.getBoundingClientRect();
      const currentX = e.clientX - rect.left;
      const currentY = e.clientY - rect.top;
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(currentX, currentY);
      ctx.stroke();
      lastX = currentX;
      lastY = currentY;
    }

    function stopDrawing() {
      isDrawing = false;
    }
  </script>
</body>
</html>