<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Muse Mirror</title>
    <style>
        @import url('https://fonts.cdnjs.com/css2?family=Inter:wght@300;400&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: white;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            position: relative;
        }

        #fixed-center {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 800px;
        }

        #input-line {
            display: flex;
            align-items: center;
            height: 30px;
        }

        #displayed-text {
            font-weight: 300;
            font-size: 20px;
            letter-spacing: -0.01em;
            color: #333;
            white-space: pre;
        }

        #cursor {
            display: inline-block;
            width: 2px;
            height: 24px;
            background-color: #333;
            animation: breathe 4.5s infinite ease-in-out;
            margin-left: 1px;
        }

        @keyframes breathe {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }
        
        /* Special class that modifies the breathing animation to slowly fade out */
        .fading-cursor {
            animation: fadeBreath 9s forwards ease-in-out !important;
        }
        
        @keyframes fadeBreath {
            0% { opacity: 0.2; } 
            25% { opacity: 1; }    /* Initial breathing cycle */
            50% { opacity: 0.1; }  /* Second breath getting weaker */
            75% { opacity: 0.4; }  /* Last partial breath */
            100% { opacity: 0; }   /* Finally fading away */
        }

        #hidden-input {
            position: absolute;
            opacity: 0;
            height: 0;
            width: 0;
        }

        #conversation {
            position: absolute;
            width: 100%;
            max-height: 45vh;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse;
            bottom: 100%;
            margin-bottom: 10px;
        }

        .conversation-item {
            margin-bottom: 10px;
            font-size: 20px;
            letter-spacing: -0.01em;
            font-weight: 300;
            line-height: 1.5;
            text-align: left;
            transition: transform 0.4s ease-out;
        }

        .user-text { 
            color: #333;
        }
        
        .response-text { 
            color: #666;
            opacity: 0;
            animation: fadeIn 2s forwards;
        }
        
        .smooth-transition {
            transition: opacity 0.5s ease-out;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        /* Heat map canvas container */
        #canvas-container {
            position: fixed;
            width: 100vw;
            height: 45vh;
            left: 0;
            right: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
            display: none; /* Initially hidden completely */
            border-radius: 8px;
            overflow: hidden;
        }
        
        #heatmap-canvas {
            width: 100%;
            height: 100%;
            background-color: white;
            cursor: circle;
        }
        
        .canvas-visible {
            opacity: 1 !important;
        }

        /* No controls or info text for pure simplicity */
    </style>
</head>
<body>
    <div id="fixed-center">
        <div id="conversation"></div>
        <div id="input-line">
            <span id="displayed-text"></span>
            <span id="cursor"></span>
            <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
        </div>
    </div>
    <div id="canvas-container">
        <canvas id="heatmap-canvas"></canvas>
    </div>
    <!-- Removed controls and info text for pure simplicity -->

    <script>
        const hiddenInput = document.getElementById('hidden-input');
        const displayedText = document.getElementById('displayed-text');
        const conversation = document.getElementById('conversation');
        const inputLine = document.getElementById('input-line');
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('heatmap-canvas');
        const ctx = canvas.getContext('2d');
        
        // Track message count for the 8-message limit
        let messageCount = 0;
        const MESSAGE_LIMIT = 8;
        
        // Heat map variables
        let isMouseDown = false;
        let mouseStartTime = 0;
        let canvasActivated = false;
        const touches = {};
        const heatData = {};
        let animationId = null;
        const fadeSpeed = 0.99;
        const maxIntensity = 255;
        const touchRadius = 20;
        const heatIncrement = 12;

        function focusInput() {
            hiddenInput.focus();
        }

        // Set canvas position dynamically based on cursor position
        function positionCanvas() {
            const cursorElement = document.getElementById('cursor');
            const cursorRect = cursorElement.getBoundingClientRect();
            
            // Position canvas right at the bottom of the cursor
            canvasContainer.style.top = (cursorRect.bottom) + 'px';
        }
        
        // Set up heatmap canvas
        function setupCanvas() {
            // Position the canvas based on cursor position
            positionCanvas();
            
            // Get the display pixel ratio for high-resolution displays
            const dpr = window.devicePixelRatio || 1;
            
            // Set actual size in memory (scaled to account for extra pixel density)
            canvas.width = canvasContainer.offsetWidth * dpr;
            canvas.height = canvasContainer.offsetHeight * dpr;
            
            // Scale the context to ensure correct drawing operations
            ctx.scale(dpr, dpr);
            
            // Set display size (CSS pixels)
            canvas.style.width = canvasContainer.offsetWidth + 'px';
            canvas.style.height = canvasContainer.offsetHeight + 'px';
            
            // Clear the canvas with white background
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        // Update heat map
        function updateHeatMap() {
            // Create image data
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Apply heat values and fade
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const key = `${x},${y}`;
                    
                    if (heatData[key]) {
                        // Fade the heat value
                        heatData[key] *= fadeSpeed;
                        
                        // If heat is too low, delete the point
                        if (heatData[key] < 0.1) {
                            delete heatData[key];
                            continue;
                        }
                        
                        // Calculate the pixel index
                        const index = (y * canvas.width + x) * 4;
                        
                        // Set RGB values based on heat (grayscale from white to black)
                        const intensity = 255 - Math.min(255, Math.floor(heatData[key]));
                        data[index] = intensity;     // R
                        data[index + 1] = intensity; // G
                        data[index + 2] = intensity; // B
                        data[index + 3] = 255;       // A (always full opacity)
                    }
                }
            }
            
            // Put the image data back
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Animation loop
        function animate() {
            updateHeatMap();
            animationId = requestAnimationFrame(animate);
        }
        
        // Add heat to points
        function addHeat(x, y, intensity) {
            // Calculate grid position
            const gridX = Math.floor(x);
            const gridY = Math.floor(y);
            
            // Add heat to points in a radius around the touch
            for (let offsetY = -touchRadius; offsetY <= touchRadius; offsetY++) {
                for (let offsetX = -touchRadius; offsetX <= touchRadius; offsetX++) {
                    const currentX = gridX + offsetX;
                    const currentY = gridY + offsetY;
                    
                    // Skip if outside canvas
                    if (currentX < 0 || currentX >= canvas.width || currentY < 0 || currentY >= canvas.height) {
                        continue;
                    }
                    
                    // Calculate distance from center of touch
                    const distance = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
                    
                    // Skip if outside radius
                    if (distance > touchRadius) {
                        continue;
                    }
                    
                    // Calculate falloff based on distance (closer = more heat)
                    const falloff = 1 - (distance / touchRadius);
                    
                    // Add heat to this point
                    const key = `${currentX},${currentY}`;
                    heatData[key] = (heatData[key] || 0) + intensity * falloff;
                    
                    // Cap heat at maximum
                    if (heatData[key] > maxIntensity) {
                        heatData[key] = maxIntensity;
                    }
                }
            }
        }
        
        // Handle touch events for heatmap
        function handleStart(e) {
            e.preventDefault();
            
            // Add new touches
            const newTouches = e.changedTouches;
            for (let i = 0; i < newTouches.length; i++) {
                const touch = newTouches[i];
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                // Store touch data
                touches[touch.identifier] = {
                    x: x,
                    y: y,
                    startTime: Date.now()
                };
                
                // Add initial heat
                addHeat(x, y, heatIncrement);
            }
        }
        
        function handleMove(e) {
            e.preventDefault();
            
            // Process changed touches
            const activeTouches = e.changedTouches;
            for (let i = 0; i < activeTouches.length; i++) {
                const touch = activeTouches[i];
                
                // Get touch data
                if (touches[touch.identifier]) {
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    // Calculate time-based intensity (longer touch = more heat)
                    const touchDuration = Date.now() - touches[touch.identifier].startTime;
                    const timeMultiplier = Math.min(5, 1 + (touchDuration / 500));
                    
                    // Update position
                    touches[touch.identifier].x = x;
                    touches[touch.identifier].y = y;
                    
                    // Add heat based on time held
                    addHeat(x, y, heatIncrement * timeMultiplier);
                }
            }
        }
        
        function handleEnd(e) {
            e.preventDefault();
            
            // Remove ended touches
            const endedTouches = e.changedTouches;
            for (let i = 0; i < endedTouches.length; i++) {
                const touch = endedTouches[i];
                delete touches[touch.identifier];
            }
        }
        
        // Mouse event handlers for heatmap
        function handleMouseDown(e) {
            e.preventDefault();
            isMouseDown = true;
            mouseStartTime = Date.now();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            addHeat(x, y, heatIncrement);
        }
        
        function handleMouseMove(e) {
            if (!isMouseDown) return;
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Calculate time-based intensity
            const mouseDuration = Date.now() - mouseStartTime;
            const timeMultiplier = Math.min(5, 1 + (mouseDuration / 500));
            
            addHeat(x, y, heatIncrement * timeMultiplier);
        }
        
        function handleMouseUp(e) {
            e.preventDefault();
            isMouseDown = false;
        }

        // Initialize
        window.onload = function() {
            focusInput();
            
            // Don't initialize canvas yet, wait for first input
            
            // Handle resize
            window.addEventListener('resize', function() {
                if (canvasActivated) {
                    setupCanvas();
                    positionCanvas();
                }
            });
        };
        
        document.addEventListener('click', function(e) {
            // Only focus input if not clicking on canvas or buttons
            if (e.target !== canvas && e.target.tagName !== 'BUTTON') {
                focusInput();
            }
        });
        
        inputLine.addEventListener('click', focusInput);

        hiddenInput.addEventListener('input', () => {
            displayedText.textContent = hiddenInput.value;
        });

        hiddenInput.addEventListener('keydown', async (e) => {
            if (e.key === 'Enter' && hiddenInput.value.trim() !== '') {
                e.preventDefault();

                const userText = hiddenInput.value.trim();
                
                // Add transition class with faster fade-out
                displayedText.classList.add('smooth-transition');
                
                // Create user message element
                const userItem = document.createElement('div');
                userItem.classList.add('conversation-item', 'user-text');
                userItem.textContent = userText;
                
                // Smoothly transition the input text out
                displayedText.style.opacity = '0';
                
                // Wait for shorter fade-out transition to complete
                setTimeout(() => {
                    // Clear input
                    hiddenInput.value = '';
                    displayedText.textContent = '';
                    
                    // Reset opacity for next input
                    displayedText.style.opacity = '1';
                    
                    // Add the message to conversation
                    conversation.prepend(userItem);
                    
                    // Increment message count
                    messageCount++;
                    
                    // After first input, make canvas available
                    if (!canvasActivated) {
                        // Display the canvas
                        canvasContainer.style.display = 'block';
                        
                        // Position everything properly
                        positionCanvas();
                        
                        // Initialize canvas
                        setupCanvas();
                        
                        // Start the animation loop
                        animate();
                        
                        // Add event listeners for touch events
                        canvas.addEventListener('touchstart', handleStart, false);
                        canvas.addEventListener('touchmove', handleMove, false);
                        canvas.addEventListener('touchend', handleEnd, false);
                        canvas.addEventListener('touchcancel', handleEnd, false);
                        
                        // Add event listeners for mouse events
                        canvas.addEventListener('mousedown', handleMouseDown);
                        canvas.addEventListener('mousemove', handleMouseMove);
                        canvas.addEventListener('mouseup', handleMouseUp);
                        canvas.addEventListener('mouseleave', handleMouseUp);
                        
                        // Make canvas visible
                        canvasContainer.classList.add('canvas-visible');
                        
                        // Update the flag
                        canvasActivated = true;
                    }
                    
                    // Simple function to handle reaching message limit
                    function handleMessageLimit() {
                        // Get the cursor element
                        const cursor = document.getElementById('cursor');
                        
                        // Apply the special fading animation class
                        if (cursor) {
                            cursor.classList.add('fading-cursor');
                        }
                        
                        // Disable input
                        hiddenInput.disabled = true;
                    }
                    
                    // Now wait before showing response
                    setTimeout(async () => {
                        try {
                            const response = await fetch('/api/mirror', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ message: userText })
                            });

                            const data = await response.json();

                            const responseItem = document.createElement('div');
                            responseItem.classList.add('conversation-item', 'response-text');
                            responseItem.textContent = data.reply;
                            conversation.prepend(responseItem);
                            
                            // Increment message count again (response counts as a message)
                            messageCount++;
                            
                            // Check if we've reached the message limit
                            if (messageCount >= MESSAGE_LIMIT) {
                                handleMessageLimit();
                            }

                        } catch (error) {
                            console.error('Error:', error);
                            
                            // Fallback in case API fails
                            const fallbackResponses = [
                                "The quietest answer is often the most profound.",
                                "Your words create the space between thoughts.",
                                "Reflections aren't answers—they're continuations of questions.",
                                "What if the question itself is the journey?",
                                "Sometimes clarity comes from simply hearing yourself think.",
                                "In stillness, even incomplete thoughts find their meaning.",
                                "The mirror doesn't judge what it reflects.",
                                "Your voice carries more wisdom than you realize.",
                                "Between intention and expression lies a universe of meaning.",
                                "The pause after a thought is where understanding begins."
                            ];
                            
                            const responseItem = document.createElement('div');
                            responseItem.classList.add('conversation-item', 'response-text');
                            responseItem.textContent = fallbackResponses[Math.floor(Math.random() * fallbackResponses.length)];
                            conversation.prepend(responseItem);
                            
                            // Increment message count again (fallback response counts as a message)
                            messageCount++;
                            
                            // Check if we've reached the message limit
                            if (messageCount >= MESSAGE_LIMIT) {
                                // Get the cursor element and hide it
                                const cursor = document.getElementById('cursor');
                                if (cursor) {
                                    cursor.style.cssText = 'display: none;';
                                }
                                
                                // Disable input
                                hiddenInput.disabled = true;
                                
                                // Show message limit reached visually
                                inputLine.style.opacity = '0.5';
                            }
                        }
                    }, 500);
                }, 500);
            }
        });
    </script>
</body>
</html>